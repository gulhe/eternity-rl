"""The goal of this module is to generate the data for the model.

The data is generated using the following steps:
    1. Generate a random instance of the environment in a perfect state.
    2. Randomly select two tiles, roll and swap them.
    3. Repeat step 2 for a given number of iterations.
    4. Save the action taken and the resulting state.
"""

from typing import Any

import numpy as np

from ..environment.gym import EAST, NORTH, SOUTH, WALL_ID, WEST, EternityEnv


def generate_perfect_instance(
    size: int,
    n_classes: int,
    seed: int = 0,
) -> np.ndarray:
    """Generate a perfect instance of the environment.
    A perfect instance is an instance where all the tiles are
    correctly placed.
    """
    rng = np.random.default_rng(seed)
    instance = np.zeros((4, size, size), dtype=np.int32)

    def fill_tile(instance: np.ndarray, coords: tuple[int, int]):
        """Fill the given tile with random classes.
        Takes into account the walls at the borders.
        """
        y, x = coords

        # South filling.
        if y == 0:  # The tile is at the bottom of the map.
            instance[SOUTH, y, x] = WALL_ID
        else:  # Copy from the tile below.
            instance[SOUTH, y, x] = instance[NORTH, y - 1, x]

        # West filling.
        if x == 0:
            instance[WEST, y, x] = WALL_ID
        else:
            instance[WEST, y, x] = instance[EAST, y, x - 1]

        # North filling.
        if y == size - 1:
            instance[NORTH, y, x] = WALL_ID
        else:
            instance[NORTH, y, x] = rng.integers(1, n_classes)

        # East filling.
        if x == size - 1:
            instance[EAST, y, x] = WALL_ID
        else:
            instance[EAST, y, x] = rng.integers(1, n_classes)

    # Generate the instance from the bottom left to the top right.
    for y in range(size):
        for x in range(size):
            fill_tile(instance, (y, x))

    return instance


def generate_sample(
    size: int,
    n_classes: int,
    n_steps: int,
    seed: int = 0,
) -> tuple[np.ndarray, np.ndarray]:
    """Generate the data for the model.
    The data is generated by generating a perfect instance of the
    environment and randomly swapping two tiles.
    """
    rng = np.random.default_rng(seed)
    instance = generate_perfect_instance(size, n_classes, seed=seed)
    env = EternityEnv(instance)
    instances = np.zeros((n_steps, 4, size, size), dtype=np.int32)

    # Sample random actions.
    swaps = rng.integers(0, size**2, size=(n_steps, 2))
    rolls = rng.integers(0, 4, size=(n_steps, 2))

    actions = np.zeros((n_steps, 4), dtype=np.int32)
    actions[:, ::2] = swaps
    actions[:, 1::2] = rolls

    # Take the actions.
    for step_id, action in enumerate(actions):
        env.step(action)
        instances[step_id] = env.render()

    # Revert the actions.
    rolls = (np.flip(rolls, axis=1) * -1) % 4
    actions[:, ::2] = swaps
    actions[:, 1::2] = rolls
    actions = np.flip(actions, axis=0)

    # Revert the instances.
    instances = np.flip(instances, axis=0)

    return instances, actions


def main(config: dict[str, Any]):
    """Generate data to be used to train a model."""
    import os
    from pathlib import Path

    from tqdm import tqdm

    # Get environment infos.
    env = EternityEnv(
        instance_path=config["env"]["path"],
        reward_type=config["env"]["reward_type"],
    )

    # Generate data.
    n_steps = env.max_steps * 2
    instances = np.zeros(
        (config["data_generation"]["n_samples"], n_steps, 4, env.size, env.size),
        dtype=np.int32,
    )
    actions = np.zeros(
        (config["data_generation"]["n_samples"], n_steps, 4),
        dtype=np.int32,
    )
    for sample_id in tqdm(range(config["data_generation"]["n_samples"])):
        inst, act = generate_sample(
            env.size,
            env.n_class,
            n_steps,
            config["seed"],
        )

        instances[sample_id] = inst
        actions[sample_id] = act

    # Save data.
    os.makedirs("./data", exist_ok=True)
    filename = os.path.basename(config["env"]["path"]).replace(".txt", ".npz")
    filepath = Path("./data") / filename
    np.savez_compressed(filepath, instances=instances, actions=actions)
